# Troubleshooting - Sistema de Fila Global

## üîß Problemas Comuns e Solu√ß√µes

### 1. Problemas de Fila

#### ‚ùå Problema: Fila crescendo constantemente

**Sintomas:**
- Queue size aumentando continuamente
- Rate limit constantemente esgotado
- Lat√™ncia alta no processamento

**Diagn√≥stico:**
```bash
# Verificar tamanho da fila
curl "http://localhost:8080/queue/stats" -H "apikey: BQYHJGJHJ"

# Verificar logs de erro
grep "rate.limit" logs/queue.log | tail -20

# Verificar distribui√ß√£o por inst√¢ncia
grep "enqueue" logs/queue.log | jq -r '.instanceName' | sort | uniq -c | sort -nr
```

**Solu√ß√µes:**

1. **Aumentar Rate Limit Temporariamente:**
```bash
curl -X PUT "http://localhost:8080/config/rate-limit" \
  -H "Content-Type: application/json" \
  -H "apikey: BQYHJGJHJ" \
  -d '{
    "capacity": 1000,
    "refillRate": 1000,
    "duration": 3600000
  }'
```

2. **Aplicar Filtros Emergenciais:**
```bash
curl -X POST "http://localhost:8080/filters/emergency" \
  -H "Content-Type: application/json" \
  -H "apikey: BQYHJGJHJ" \
  -d '{
    "enabled": true,
    "minDurationSeconds": 10,
    "maxDurationSeconds": 30,
    "reason": "Emergency filter - high load"
  }'
```

3. **Identificar Inst√¢ncias Problem√°ticas:**
```bash
# Listar top 10 inst√¢ncias por volume
grep "enqueue" logs/queue.log | \
  jq -r '.instanceName' | \
  sort | uniq -c | sort -nr | head -10

# Aplicar filtro espec√≠fico para inst√¢ncia problem√°tica
curl -X PUT "http://localhost:8080/instance/PROBLEMA_INSTANCE/filters/audio" \
  -H "Content-Type: application/json" \
  -H "apikey: BQYHJGJHJ" \
  -d '{
    "minDurationSeconds": 15,
    "maxDurationSeconds": 60,
    "enabled": true
  }'
```

#### ‚ùå Problema: Mensagens sendo perdidas

**Sintomas:**
- Mensagens n√£o chegam ao webhook
- Queue stats mostra processamento mas webhook n√£o recebe

**Diagn√≥stico:**
```bash
# Verificar logs de webhook
grep "webhook.*error" logs/webhook.log | tail -10

# Verificar conectividade do webhook
curl "http://localhost:8080/webhook/global/test" \
  -H "Content-Type: application/json" \
  -H "apikey: BQYHJGJHJ" \
  -d '{"url": "https://your-webhook.com", "type": "principal"}'

# Verificar configura√ß√£o de webhook
curl "http://localhost:8080/webhook/global/config" -H "apikey: BQYHJGJHJ"
```

**Solu√ß√µes:**

1. **Verificar e Corrigir URL do Webhook:**
```bash
curl -X PUT "http://localhost:8080/webhook/global/config" \
  -H "Content-Type: application/json" \
  -H "apikey: BQYHJGJHJ" \
  -d '{
    "principal": {
      "enabled": true,
      "url": "https://webhook-correto.com/endpoint"
    }
  }'
```

2. **Configurar Retry Policy:**
```bash
# Habilitar retry autom√°tico
curl -X PUT "http://localhost:8080/webhook/config/retry" \
  -H "Content-Type: application/json" \
  -H "apikey: BQYHJGJHJ" \
  -d '{
    "enabled": true,
    "maxRetries": 3,
    "backoffMs": 5000
  }'
```

---

### 2. Problemas de S3/MinIO

#### ‚ùå Problema: Uploads S3 falhando

**Sintomas:**
- Errors "connection refused" para MinIO
- Mensagens de √°udio sendo rejeitadas
- Logs mostram falhas de upload

**Diagn√≥stico:**
```bash
# Verificar status do MinIO
curl http://localhost:9000/minio/health/live

# Verificar logs S3
grep "s3.*error" logs/s3.log | tail -10

# Verificar espa√ßo em disco
df -h /path/to/minio-data

# Verificar configura√ß√£o S3
echo $MINIO_ENDPOINT $MINIO_ACCESS_KEY
```

**Solu√ß√µes:**

1. **Restart do MinIO:**
```bash
# Parar MinIO
pkill minio

# Reiniciar com configura√ß√µes corretas
MINIO_ROOT_USER=evolution MINIO_ROOT_PASSWORD=evolution123 \
./minio server ./minio-data --console-address ":9001" --address ":9000"
```

2. **Verificar Credenciais:**
```bash
# Testar acesso com credentials
export AWS_ACCESS_KEY_ID=evolution
export AWS_SECRET_ACCESS_KEY=evolution123
aws s3 ls --endpoint-url http://localhost:9000
```

3. **Limpeza de Espa√ßo:**
```bash
# Executar cleanup emergencial
curl -X POST "http://localhost:8080/cleanup/execute" \
  -H "apikey: BQYHJGJHJ"

# Verificar resultado
curl "http://localhost:8080/cleanup/status" \
  -H "apikey: BQYHJGJHJ"
```

#### ‚ùå Problema: Cleanup S3 n√£o executando

**Sintomas:**
- Arquivos antigos acumulando
- Espa√ßo em disco esgotando
- Cleanup schedule n√£o funciona

**Diagn√≥stico:**
```bash
# Verificar configura√ß√£o do cleanup
curl "http://localhost:8080/cleanup/schedule" -H "apikey: BQYHJGJHJ"

# Verificar logs do scheduler
grep "cleanup" logs/application.log | tail -10

# Verificar timezone
timedatectl status
```

**Solu√ß√µes:**

1. **Reconfigurar Schedule:**
```bash
curl -X PUT "http://localhost:8080/cleanup/schedule" \
  -H "Content-Type: application/json" \
  -H "apikey: BQYHJGJHJ" \
  -d '{
    "enabled": true,
    "retentionDays": 1,
    "dailyTime": "03:00",
    "timezone": "America/Sao_Paulo"
  }'
```

2. **Executar Limpeza Manual:**
```bash
curl -X POST "http://localhost:8080/cleanup/execute" \
  -H "apikey: BQYHJGJHJ"
```

---

### 3. Problemas de Processing Feedback

#### ‚ùå Problema: Reactions n√£o aparecem no WhatsApp

**Sintomas:**
- Processing iniciado mas sem feedback visual
- Usu√°rios n√£o veem reactions de progresso
- Sessions ativas mas sem intera√ß√£o

**Diagn√≥stico:**
```bash
# Verificar sess√µes ativas
curl "http://localhost:8080/process/status" -H "apikey: BQYHJGJHJ"

# Verificar logs de reaction
grep "reaction" logs/application.log | tail -10

# Verificar configura√ß√£o da inst√¢ncia WhatsApp
# (verificar se inst√¢ncia est√° conectada)
```

**Solu√ß√µes:**

1. **Verificar Conex√£o da Inst√¢ncia:**
```bash
# Verificar status da inst√¢ncia WhatsApp
curl "http://localhost:8080/instance/INSTANCE_NAME/connect" \
  -H "apikey: BQYHJGJHJ"
```

2. **Reiniciar Sess√£o de Processing:**
```bash
# For√ßar limpeza e reiniciar
curl -X DELETE "http://localhost:8080/process/INSTANCE:CHAT:MESSAGE" \
  -H "apikey: BQYHJGJHJ"

# Iniciar nova sess√£o
curl -X POST "http://localhost:8080/process/start" \
  -H "Content-Type: application/json" \
  -H "apikey: BQYHJGJHJ" \
  -d '{
    "instance": "INSTANCE_NAME",
    "chatId": "CHAT_ID",
    "messageId": "MESSAGE_ID"
  }'
```

#### ‚ùå Problema: Muitos timeouts de processing

**Sintomas:**
- Reactions ü§∑ frequentes
- Sess√µes expirando antes de finalizar
- Processing time muito alto

**Diagn√≥stico:**
```bash
# Analisar tempo m√©dio de processing
curl "http://localhost:8080/process/status" -H "apikey: BQYHJGJHJ" | \
  jq '.stats.averageProcessingTime'

# Verificar distribui√ß√£o de timeouts
grep "timeout" logs/application.log | wc -l

# Identificar gargalos
curl "http://localhost:8080/queue/stats" -H "apikey: BQYHJGJHJ"
```

**Solu√ß√µes:**

1. **Aumentar Timeout:**
```bash
# Configurar timeout maior
export PROCESSING_FEEDBACK_TIMEOUT=900000  # 15 minutos
```

2. **Otimizar Processing:**
```bash
# Aumentar rate limit para reduzir fila
curl -X PUT "http://localhost:8080/config/rate-limit" \
  -d '{"capacity": 1000, "refillRate": 1000}'

# Aplicar filtros para reduzir carga
curl -X PUT "http://localhost:8080/instance/ALL/filters/audio" \
  -d '{"maxDurationSeconds": 120}'
```

---

### 4. Problemas de Webhook

#### ‚ùå Problema: Webhooks n√£o sendo entregues

**Sintomas:**
- Client systems n√£o recebem dados
- Webhook response time muito alto
- Errors 500/timeout nos webhooks

**Diagn√≥stico:**
```bash
# Verificar configura√ß√£o de webhooks
curl "http://localhost:8080/webhook/global/config" -H "apikey: BQYHJGJHJ"

# Testar conectividade
curl "http://localhost:8080/webhook/global/test" \
  -d '{"url": "https://your-webhook.com", "type": "principal"}'

# Verificar logs de webhook
grep "webhook.*error" logs/webhook.log | tail -20
```

**Solu√ß√µes:**

1. **Verificar URL e Conectividade:**
```bash
# Testar URL manualmente
curl -X POST "https://your-webhook.com/endpoint" \
  -H "Content-Type: application/json" \
  -d '{"test": true}'

# Atualizar URL se necess√°rio
curl -X PUT "http://localhost:8080/webhook/global/config" \
  -d '{"principal": {"url": "https://webhook-correto.com"}}'
```

2. **Configurar Headers de Autentica√ß√£o:**
```bash
curl -X PUT "http://localhost:8080/webhook/global/config" \
  -H "Content-Type: application/json" \
  -H "apikey: BQYHJGJHJ" \
  -d '{
    "headers": {
      "Authorization": "Bearer YOUR_TOKEN",
      "Content-Type": "application/json"
    }
  }'
```

3. **Habilitar Retry:**
```bash
curl -X PUT "http://localhost:8080/webhook/config/retry" \
  -d '{
    "enabled": true,
    "maxRetries": 5,
    "backoffMs": 10000
  }'
```

---

### 5. Problemas de Database

#### ‚ùå Problema: Queries lentas

**Sintomas:**
- API responses lentas
- Database connection timeout
- Configura√ß√µes n√£o carregando

**Diagn√≥stico:**
```bash
# Verificar conex√µes ativas
psql $DATABASE_URL -c "SELECT count(*) FROM pg_stat_activity;"

# Verificar queries lentas
psql $DATABASE_URL -c "
SELECT query, mean_exec_time, calls
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 10;"

# Verificar tamanho das tabelas
psql $DATABASE_URL -c "
SELECT schemaname,tablename,attname,n_distinct,correlation
FROM pg_stats
WHERE tablename = 'instance_audio_filters';"
```

**Solu√ß√µes:**

1. **Otimizar Banco:**
```bash
# Executar VACUUM e ANALYZE
psql $DATABASE_URL -c "VACUUM ANALYZE instance_audio_filters;"
psql $DATABASE_URL -c "VACUUM ANALYZE global_webhook_config;"

# Recriar √≠ndices
psql $DATABASE_URL -c "REINDEX TABLE instance_audio_filters;"
```

2. **Adicionar √çndices Missing:**
```sql
-- Adicionar √≠ndices para performance
CREATE INDEX IF NOT EXISTS idx_instance_filters_enabled
ON instance_audio_filters(enabled) WHERE enabled = true;

CREATE INDEX IF NOT EXISTS idx_processing_stats_date
ON processing_stats(date DESC);
```

3. **Configurar Connection Pool:**
```env
# Ajustar pool de conex√µes
DATABASE_POOL_SIZE=20
DATABASE_POOL_TIMEOUT=30000
```

---

### 6. Problemas de Rate Limiting

#### ‚ùå Problema: Rate limit muito restritivo

**Sintomas:**
- Muitas mensagens sendo rejeitadas
- Tokens sempre baixos
- Users reclamando de lentid√£o

**Diagn√≥stico:**
```bash
# Verificar status do rate limit
curl "http://localhost:8080/queue/stats" -H "apikey: BQYHJGJHJ" | \
  jq '.rateLimitStatus'

# Analisar padr√£o de consumo
grep "rate.limit" logs/queue.log | \
  awk '{print $1, $2}' | \
  sort | uniq -c
```

**Solu√ß√µes:**

1. **Ajustar Configura√ß√£o:**
```bash
# Aumentar capacidade
curl -X PUT "http://localhost:8080/config/rate-limit" \
  -d '{
    "capacity": 1000,
    "refillRate": 1000,
    "refillInterval": 60000
  }'
```

2. **Implementar Rate Limiting por Inst√¢ncia:**
```bash
# Configurar limite espec√≠fico para inst√¢ncias VIP
curl -X PUT "http://localhost:8080/instance/VIP_INSTANCE/rate-limit" \
  -d '{
    "capacity": 100,
    "refillRate": 100
  }'
```

---

## üîç Ferramentas de Diagn√≥stico

### 1. Script de Diagn√≥stico Completo

```bash
#!/bin/bash
# diagnosis.sh

echo "üîç DIAGN√ìSTICO COMPLETO - $(date)"
echo "=================================="

API_KEY="BQYHJGJHJ"
BASE_URL="http://localhost:8080"

# 1. Health Check Geral
echo "1. HEALTH CHECK"
health=$(curl -s "$BASE_URL/health" -H "apikey: $API_KEY")
echo "Status: $(echo $health | jq -r '.status')"
echo "Uptime: $(echo $health | jq -r '.uptime')"
echo ""

# 2. Status da Fila
echo "2. FILA GLOBAL"
queue_stats=$(curl -s "$BASE_URL/queue/stats" -H "apikey: $API_KEY")
echo "Tamanho da fila: $(echo $queue_stats | jq -r '.queueSize')"
echo "Processadas hoje: $(echo $queue_stats | jq -r '.processedToday')"
echo "Rate limit tokens: $(echo $queue_stats | jq -r '.rateLimitStatus.tokens')"
echo ""

# 3. Processing Feedback
echo "3. PROCESSING FEEDBACK"
process_status=$(curl -s "$BASE_URL/process/status" -H "apikey: $API_KEY")
echo "Sess√µes ativas: $(echo $process_status | jq -r '.activeSessionsCount')"
echo "Tempo m√©dio: $(echo $process_status | jq -r '.stats.averageProcessingTime')ms"
echo ""

# 4. S3 Cleanup
echo "4. S3 CLEANUP"
cleanup_status=$(curl -s "$BASE_URL/cleanup/status" -H "apikey: $API_KEY")
echo "Enabled: $(echo $cleanup_status | jq -r '.enabled')"
echo "Pr√≥xima execu√ß√£o: $(echo $cleanup_status | jq -r '.nextExecution')"
echo ""

# 5. Webhook Config
echo "5. WEBHOOK CONFIG"
webhook_config=$(curl -s "$BASE_URL/webhook/global/config" -H "apikey: $API_KEY")
echo "Principal habilitado: $(echo $webhook_config | jq -r '.data.principal.enabled')"
echo "Monitoring habilitado: $(echo $webhook_config | jq -r '.data.monitoramento.enabled')"
echo ""

# 6. Verificar Servi√ßos
echo "6. SERVI√áOS DEPENDENTES"
# PostgreSQL
if pg_isready -q; then
  echo "PostgreSQL: ‚úÖ OK"
else
  echo "PostgreSQL: ‚ùå ERRO"
fi

# RabbitMQ
if curl -s http://localhost:15672 > /dev/null; then
  echo "RabbitMQ: ‚úÖ OK"
else
  echo "RabbitMQ: ‚ùå ERRO"
fi

# MinIO
if curl -s http://localhost:9000/minio/health/live > /dev/null; then
  echo "MinIO: ‚úÖ OK"
else
  echo "MinIO: ‚ùå ERRO"
fi

echo ""

# 7. An√°lise de Logs
echo "7. AN√ÅLISE DE LOGS (√∫ltimas 24h)"
if [ -f "logs/application.log" ]; then
  errors=$(grep -c '"level":"error"' logs/application.log || echo "0")
  warnings=$(grep -c '"level":"warn"' logs/application.log || echo "0")
  echo "Errors: $errors"
  echo "Warnings: $warnings"
else
  echo "Logs n√£o encontrados"
fi

echo ""
echo "=================================="
echo "Diagn√≥stico conclu√≠do"
```

### 2. Monitor de Performance em Tempo Real

```bash
#!/bin/bash
# real-time-monitor.sh

API_KEY="BQYHJGJHJ"
BASE_URL="http://localhost:8080"

# Limpar tela
clear

while true; do
  # Posicionar cursor no topo
  tput cup 0 0

  echo "üîÑ MONITOR TEMPO REAL - $(date)"
  echo "=================================="

  # Queue stats
  queue_stats=$(curl -s "$BASE_URL/queue/stats" -H "apikey: $API_KEY")
  queue_size=$(echo $queue_stats | jq -r '.queueSize')
  tokens=$(echo $queue_stats | jq -r '.rateLimitStatus.tokens')
  capacity=$(echo $queue_stats | jq -r '.rateLimitStatus.capacity')

  echo "Fila: $queue_size mensagens"
  echo "Rate Limit: $tokens/$capacity tokens"

  # Calcular % de uso
  usage=$(echo "scale=1; (($capacity - $tokens) * 100) / $capacity" | bc -l)
  echo "Uso: ${usage}%"

  # Processing sessions
  process_status=$(curl -s "$BASE_URL/process/status" -H "apikey: $API_KEY")
  active_sessions=$(echo $process_status | jq -r '.activeSessionsCount')
  avg_time=$(echo $process_status | jq -r '.stats.averageProcessingTime')

  echo "Sess√µes ativas: $active_sessions"
  echo "Tempo m√©dio: ${avg_time}ms"

  # Alertas
  echo ""
  echo "ALERTAS:"
  if [ "$queue_size" -gt 500 ]; then
    echo "‚ö†Ô∏è  Fila muito grande"
  fi
  if [ "$tokens" -lt 50 ]; then
    echo "‚ö†Ô∏è  Rate limit baixo"
  fi
  if [ "$active_sessions" -gt 50 ]; then
    echo "‚ö†Ô∏è  Muitas sess√µes ativas"
  fi

  echo ""
  echo "Ctrl+C para sair"
  echo "=================================="

  # Aguardar 5 segundos
  sleep 5
done
```

### 3. Gerador de Relat√≥rio de An√°lise

```bash
#!/bin/bash
# generate-analysis-report.sh

REPORT_DATE=$(date +%Y%m%d_%H%M%S)
REPORT_FILE="analysis_report_$REPORT_DATE.md"

cat > $REPORT_FILE << EOF
# Relat√≥rio de An√°lise - Sistema de Fila Global

**Data**: $(date)
**Per√≠odo**: √öltimas 24 horas

## Resumo Executivo

EOF

# Coletar dados
API_KEY="BQYHJGJHJ"
BASE_URL="http://localhost:8080"

# Estat√≠sticas atuais
queue_stats=$(curl -s "$BASE_URL/queue/stats" -H "apikey: $API_KEY")

cat >> $REPORT_FILE << EOF
### M√©tricas Atuais

- **Tamanho da Fila**: $(echo $queue_stats | jq -r '.queueSize') mensagens
- **Processadas Hoje**: $(echo $queue_stats | jq -r '.processedToday')
- **Rate Limit**: $(echo $queue_stats | jq -r '.rateLimitStatus.tokens')/$(echo $queue_stats | jq -r '.rateLimitStatus.capacity') tokens
- **√Åudios Filtrados**: $(echo $queue_stats | jq -r '.audioFilterStats.tooShort + .audioFilterStats.tooLong')

### An√°lise de Logs

EOF

# An√°lise de logs
if [ -f "logs/application.log" ]; then
  errors=$(grep -c '"level":"error"' logs/application.log)
  warnings=$(grep -c '"level":"warn"' logs/application.log)

  cat >> $REPORT_FILE << EOF
- **Errors**: $errors ocorr√™ncias
- **Warnings**: $warnings ocorr√™ncias

### Top 5 Inst√¢ncias por Volume

\`\`\`
$(grep "enqueue" logs/queue.log | jq -r '.instanceName' | sort | uniq -c | sort -nr | head -5)
\`\`\`

### Distribui√ß√£o de Erros

\`\`\`
$(grep '"level":"error"' logs/application.log | jq -r '.error' | sort | uniq -c | sort -nr | head -5)
\`\`\`

EOF
fi

cat >> $REPORT_FILE << EOF
## Recomenda√ß√µes

### A√ß√µes Imediatas
- [ ] Verificar inst√¢ncias com maior volume
- [ ] Analisar erros frequentes
- [ ] Otimizar filtros se necess√°rio

### A√ß√µes Preventivas
- [ ] Monitorar rate limit usage
- [ ] Configurar alertas proativos
- [ ] Planejar scaling se necess√°rio

---
*Relat√≥rio gerado automaticamente*
EOF

echo "‚úÖ Relat√≥rio gerado: $REPORT_FILE"
```

---

## üìû Contacts de Suporte

### Escalation Contacts

| Componente | Contact | Hor√°rio |
|------------|---------|---------|
| **Aplica√ß√£o** | evolution-dev-team@company.com | 24/7 |
| **Infraestrutura** | infra-team@company.com | Business hours |
| **Database** | dba-team@company.com | Business hours |
| **Monitoring** | monitoring-team@company.com | 24/7 |

### Emergency Procedures

1. **P0 Incidents**: Ligar para on-call engineer
2. **P1 Incidents**: Slack #evolution-incidents
3. **P2/P3**: Email team + JIRA ticket

### Documentation Updates

Para atualizar esta documenta√ß√£o:
1. Criar PR com mudan√ßas
2. Review pelo team lead
3. Merge ap√≥s aprova√ß√£o
4. Notificar equipe via Slack

---

**Status**: Documenta√ß√£o completa do sistema de troubleshooting
**√öltima atualiza√ß√£o**: Outubro 2025